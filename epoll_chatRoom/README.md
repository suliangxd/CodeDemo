# 项目介绍

本项目是实现一个简单的聊天室，聊天室分为服务端和客户端。本项目将很多复杂的功能都去掉了，线程池、多线程编程、超时重传、确认收包等等都不会涉及。总共300多行代码，让大家真正了解 C/S模型，以及 epoll 的使用
------
## 知识点
+ 支持多个用户接入，实现聊天室的基本功能
+ 使用epoll机制实现并发，增加效率
+ 使用fork创建两个进程
+ 将聊天信息写到管道（pipe），并发送给父进程
+ 使用epoll机制接受服务端发来的信息，并显示给用户，使用户看到其他用户的聊天信息

## 代码说明
+ server.cpp是服务端程序
+ client.cpp是客户端程序
+ utility.h是一个头文件，包含服务端程序和客户端程序都会用到的一些头文件、变量声明、函数、宏等

## 知识点说明
TCP服务端通信的常规步骤:
```
(1)使用 socket()创建 TCP 套接字（socket）

(2)将创建的套接字绑定到一个本地地址和端口上（Bind）

(3)将套接字设为监听模式，准备接收客户端请求（listen）

(4)等待客户请求到来: 当请求到来后，接受连接请求，返回一个对应于此次连接的新的套接字（accept）

(5)用 accept 返回的套接字和客户端进行通信（使用write()/send()或send()/recv() )

(6)返回，等待另一个客户请求

(7)关闭套接字
```
TCP 客户端通信的常规步骤:
```
(1)创建套接字（socket）

(2)使用 connect() 建立到达服务器的连接（connect)

(3)客户端进行通信（使用 write()/send() 或 send()/recv() )

(4)使用 close() 关闭客户连接
```
阻塞与非阻塞 socket:
```
通常的，对一个文件描述符指定的文件或设备, 有两种工作方式: 阻塞与非阻塞方式。

1. 阻塞方式是指： 当试图对该文件描述符进行读写时，如果当时没有数据可读，或者暂时不可写，程序就进入等待状态，直到有东西可读或者可写为止。

2. 非阻塞方式是指： 如果没有数据可读，或者不可写，读写函数马上返回，而不会等待。

3. 举个例子来说，比如说小明去找一个女神聊天，女神却不在。 如果小明舍不得走，只能在女神大门口死等着，当然小明可以休息。当女 神来了，她会把你唤醒（囧，因为挡着她门了），这就是阻塞方式。如果小明发现女神不在，立即离开，以后每隔十分钟回来看一下（采用轮询方式），不在的话仍然立即离开，这就是非阻塞方式。

4. 阻塞方式和非阻塞方式唯一的区别： 是否立即返回。本项目采用更高效的做法，所以应该将socket设置为非阻塞方式。这样能充分利用服务器资源，效率得到了很大提高。
```

epoll:
epoll 是 Linux 内核为处理大批句柄而作改进的 poll ，是 Linux 特有的 I/O 函数。其特点如下:
+ epoll 是 Linux 下多路复用 IO 接口 select/poll 的增强版本。其实现和使用方式与 select/poll 有很多不同，epoll 通过一组函数来完成有关任务，而不是一个函数
+ epoll 之所以高效，是因为 epoll 将用户关心的文件描述符放到内核里的一个事件表中，而不是像 select/poll 每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll 无须遍历整个被侦听的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入就绪队列的描述符集合就行了
+ epoll 有两种工作方式，LT(level triggered)：水平触发和 ET(edge-triggered)：边沿触发。LT 是 select/poll 使用的触发方式，比较低效；而 ET 是 epoll 的高速工作方式（本项目使用 epoll 的 ET 方式）
+ 通俗理解就是，比如说有一堆女孩，有的很漂亮，有的很凤姐。现在你想找漂亮的女孩聊天，LT 就是你需要把这一堆女孩全都看一遍，才可以找到其中的漂亮的（就绪事件）；而ET是你的小弟（内核）将N个漂亮的女孩编号告诉你，你直接去看就好，所以 epoll 很高效。另外，还记得小明找女神聊天的例子吗？采用非阻塞方式，小明还需要每隔十分钟回来看一下（select）；如果小明有小弟（内核）帮他守在大门口，女神回来了，小弟会主动打电话，告诉小明女神回来了，快来处理吧！这就是 epoll

epoll 共3个函数, 如下:
```c
int epoll_create(int size)
创建一个epoll句柄，参数size用来告诉内核监听的数目，size为epoll所支持的最大句柄数
```
```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
函数功能： epoll事件注册函数
参数epfd为epoll的句柄，即epoll_create返回值
参数op表示动作，用3个宏来表示：  
EPOLL_CTL_ADD(注册新的fd到epfd)， 
EPOLL_CTL_MOD(修改已经注册的fd的监听事件)，
EPOLL_CTL_DEL(从epfd删除一个fd)；
其中参数fd为需要监听的标示符；
参数event告诉内核需要监听的事件，event的结构如下：
struct epoll_event {
    __uint32_t events; //Epoll events
      epoll_data_t data; //User data variable
};
其中介绍events是宏的集合，本项目主要使用EPOLLIN(表示对应的文件描述符可以读，即读事件发生)，其他宏类型，可以google之!
```
```c
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)
等待事件的产生，函数返回需要处理的事件数目（该数目是就绪事件的数目，就是前面所说漂亮女孩的个数N）
```
服务端使用 epoll 的时候，步骤如下：

1. 调用 epoll_create 函数在 Linux 内核中创建一个事件表；
2. 然后将文件描述符（监听套接字 listener ）添加到所创建的事件表中；
3. 在主循环中，调用 epoll_wait 等待返回就绪的文件描述符集合；
4. 分别处理就绪的事件集合，本项目中一共有两类事件：新用户连接事件和用户发来消息事件（ epoll 还有很多其他事件，本项目为简洁明了，不介绍）。
